name: Release (Tag)

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  create-release:
    name: Create GitHub release
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Secret scan (filesystem)
        shell: bash
        run: |
          set -euo pipefail
          docker run --rm \
            -v "$PWD:/work" \
            ghcr.io/trufflesecurity/trufflehog:latest \
            filesystem --no-verification --fail --exclude-paths=/work/.trufflehog-exclude.txt /work

      - name: Secret scan (git history)
        shell: bash
        run: |
          set -euo pipefail
          docker run --rm \
            -v "$PWD:/work" \
            ghcr.io/trufflesecurity/trufflehog:latest \
            git --no-verification --fail file:///work

      - name: Create release if missing
        shell: bash
        run: |
          set -euo pipefail
          gh release view "${GITHUB_REF_NAME}" >/dev/null 2>&1 || \
            gh release create "${GITHUB_REF_NAME}" --title "File Architect ${GITHUB_REF_NAME}" --notes ""

  build-macos:
    name: Build macOS (signed)
    needs: create-release
    runs-on: macos-latest
    env:
      APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
      APPLE_ID: ${{ secrets.APPLE_ID }}
      APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Validate signing configuration
        shell: bash
        env:
          APPLE_CERTIFICATE_RAW: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD_RAW: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY_RAW: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID_RAW: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD_RAW: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID_RAW: ${{ secrets.APPLE_TEAM_ID }}
          TAURI_SIGNING_PRIVATE_KEY_RAW: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD_RAW: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          TAURI_PRIVATE_KEY_RAW: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_PRIVATE_KEY_PASSWORD_RAW: ${{ secrets.TAURI_PRIVATE_KEY_PASSWORD }}
        run: |
          set -euo pipefail
          TEAM_ID="$(printf '%s' "${APPLE_TEAM_ID_RAW:-}" | tr -d '\r\n[:space:]\"')"
          TAURI_KEY_RAW="${TAURI_SIGNING_PRIVATE_KEY_RAW:-${TAURI_PRIVATE_KEY_RAW:-}}"
          TAURI_KEY_PASSWORD_RAW="${TAURI_SIGNING_PRIVATE_KEY_PASSWORD_RAW:-${TAURI_PRIVATE_KEY_PASSWORD_RAW:-}}"
          missing=()
          for key in APPLE_CERTIFICATE_RAW APPLE_CERTIFICATE_PASSWORD_RAW APPLE_SIGNING_IDENTITY_RAW APPLE_ID_RAW APPLE_PASSWORD_RAW; do
            if [[ -z "${!key:-}" ]]; then
              missing+=("$key")
            fi
          done
          if [[ "${#TEAM_ID}" -lt 3 ]]; then
            missing+=("APPLE_TEAM_ID_RAW")
          fi
          if [[ -z "${TAURI_KEY_RAW:-}" ]]; then
            missing+=("TAURI_SIGNING_PRIVATE_KEY_RAW/TAURI_PRIVATE_KEY_RAW")
          fi
          if [[ -z "${TAURI_KEY_PASSWORD_RAW:-}" ]]; then
            missing+=("TAURI_SIGNING_PRIVATE_KEY_PASSWORD_RAW/TAURI_PRIVATE_KEY_PASSWORD_RAW")
          fi
          if (( ${#missing[@]} > 0 )); then
            echo "Missing/invalid signing secrets: ${missing[*]}"
            exit 1
          fi

          # Fast preflight: validate cert/password and updater key format before heavy build steps.
          CERT_PATH="$RUNNER_TEMP/preflight-signing-cert.p12"
          printf '%s' "$APPLE_CERTIFICATE_RAW" | tr -d '\r\n' | base64 -d > "$CERT_PATH"
          openssl pkcs12 -in "$CERT_PATH" -nokeys -passin "pass:${APPLE_CERTIFICATE_PASSWORD_RAW}" >/dev/null

          KEY="$(printf '%s' "${TAURI_KEY_RAW}" | tr -d '\r')"
          if [[ "${KEY}" == *"untrusted comment:"* ]]; then
            KEY_B64="$(printf '%s' "${KEY}" | base64 | tr -d '\r\n')"
          else
            KEY_B64="$(printf '%s' "${KEY}" | tr -d '\r\n')"
          fi
          DECODED_KEY="$(printf '%s' "${KEY_B64}" | base64 -d 2>/dev/null || true)"
          if [[ "${DECODED_KEY}" != *"untrusted comment:"* ]]; then
            echo "Invalid Tauri updater key format. Secret must be raw key text or base64 key text."
            exit 1
          fi
          if [[ -z "$(printf '%s' "${TAURI_KEY_PASSWORD_RAW}" | tr -d '\r')" ]]; then
            echo "Invalid Tauri updater key password."
            exit 1
          fi

          echo "Signing secrets detected and preflight-validated."

      - name: Checkout
        uses: actions/checkout@v4

      - name: Normalize Apple team ID
        shell: bash
        env:
          APPLE_TEAM_ID_RAW: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          set -euo pipefail
          trim() {
            printf '%s' "$1" \
              | tr -d '\r' \
              | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//; s/^"//; s/"$//'
          }

          TEAM_ID="$(trim "${APPLE_TEAM_ID_RAW:-}")"
          if [[ ${#TEAM_ID} -lt 3 ]]; then
            FALLBACK_TEAM_ID="$(sed -nE 's/.*"providerShortName":[[:space:]]*"([^"]+)".*/\1/p' src-tauri/tauri.conf.json | head -n1)"
            TEAM_ID="$(trim "${FALLBACK_TEAM_ID:-}")"
          fi

          if [[ ${#TEAM_ID} -lt 3 ]]; then
            echo "APPLE_TEAM_ID is invalid after normalization. Set APPLE_TEAM_ID repo secret to your Apple Team ID."
            exit 1
          fi

          echo "::add-mask::$TEAM_ID"
          echo "APPLE_TEAM_ID=$TEAM_ID" >> "$GITHUB_ENV"
          echo "Normalized APPLE_TEAM_ID length: ${#TEAM_ID}"

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Normalize Tauri updater signing key
        shell: bash
        env:
          TAURI_SIGNING_PRIVATE_KEY_RAW: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD_RAW: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          TAURI_PRIVATE_KEY_RAW: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_PRIVATE_KEY_PASSWORD_RAW: ${{ secrets.TAURI_PRIVATE_KEY_PASSWORD }}
        run: |
          set -euo pipefail
          KEY_RAW="${TAURI_SIGNING_PRIVATE_KEY_RAW:-${TAURI_PRIVATE_KEY_RAW:-}}"
          KEY_PASSWORD_RAW="${TAURI_SIGNING_PRIVATE_KEY_PASSWORD_RAW:-${TAURI_PRIVATE_KEY_PASSWORD_RAW:-}}"
          KEY="$(printf '%s' "${KEY_RAW}" | tr -d '\r')"
          KEY_PASSWORD="$(printf '%s' "${KEY_PASSWORD_RAW}" | tr -d '\r')"

          if [[ -z "${KEY}" || -z "${KEY_PASSWORD}" ]]; then
            echo "Missing TAURI updater signing key/password after normalization."
            exit 1
          fi

          # Tauri expects updater private key as base64-encoded content.
          if [[ "${KEY}" == *"untrusted comment:"* ]]; then
            KEY_B64="$(printf '%s' "${KEY}" | base64 | tr -d '\r\n')"
          else
            KEY_B64="$(printf '%s' "${KEY}" | tr -d '\r\n')"
          fi

          DECODED_KEY="$(printf '%s' "${KEY_B64}" | base64 -d 2>/dev/null || true)"
          if [[ "${DECODED_KEY}" != *"untrusted comment:"* ]]; then
            echo "TAURI updater private key is invalid (expected raw key content or base64 key content)."
            exit 1
          fi

          echo "::add-mask::$KEY_B64"
          echo "::add-mask::$KEY_PASSWORD"
          echo "TAURI_SIGNING_PRIVATE_KEY<<EOF" >> "$GITHUB_ENV"
          echo "$KEY_B64" >> "$GITHUB_ENV"
          echo "EOF" >> "$GITHUB_ENV"
          echo "TAURI_PRIVATE_KEY<<EOF" >> "$GITHUB_ENV"
          echo "$KEY_B64" >> "$GITHUB_ENV"
          echo "EOF" >> "$GITHUB_ENV"
          echo "TAURI_SIGNING_PRIVATE_KEY_PASSWORD=$KEY_PASSWORD" >> "$GITHUB_ENV"
          echo "TAURI_PRIVATE_KEY_PASSWORD=$KEY_PASSWORD" >> "$GITHUB_ENV"
          echo "Normalized TAURI updater key length: ${#KEY_B64}"

      - name: Import Apple certificate into keychain
        shell: bash
        env:
          APPLE_CERTIFICATE_RAW: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD_RAW: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          set -euo pipefail
          CERT_PATH="$RUNNER_TEMP/signing-cert.p12"
          KEYCHAIN_PATH="$RUNNER_TEMP/signing.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -base64 24 | tr -d '\n')"

          echo "APPLE_CERTIFICATE_RAW length: ${#APPLE_CERTIFICATE_RAW}"
          printf '%s' "$APPLE_CERTIFICATE_RAW" | tr -d '\r\n' | base64 -d > "$CERT_PATH"
          echo "Decoded cert bytes: $(wc -c < "$CERT_PATH")"
          shasum -a 256 "$CERT_PATH"
          openssl pkcs12 -in "$CERT_PATH" -nokeys -passin "pass:${APPLE_CERTIFICATE_PASSWORD_RAW}" >/dev/null

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security import "$CERT_PATH" -k "$KEYCHAIN_PATH" -f pkcs12 -P "$APPLE_CERTIFICATE_PASSWORD_RAW" -A -T /usr/bin/codesign -T /usr/bin/security
          security list-keychains -d user -s "$KEYCHAIN_PATH"
          security default-keychain -d user -s "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build app
        shell: bash
        run: |
          set -euo pipefail
          # Use the certificate already imported in keychain.
          unset APPLE_CERTIFICATE
          unset APPLE_CERTIFICATE_PASSWORD
          pnpm tauri build --config src-tauri/tauri.production.conf.json

      - name: Upload release assets (macOS)
        shell: bash
        run: |
          set -euo pipefail
          APP_TAR="$(ls src-tauri/target/release/bundle/macos/*.app.tar.gz | head -n1)"
          APP_SIG="${APP_TAR}.sig"
          DMG_FILE="$(ls src-tauri/target/release/bundle/dmg/*.dmg | head -n1)"
          gh release upload "${GITHUB_REF_NAME}" "$APP_TAR" "$APP_SIG" "$DMG_FILE" --clobber

  build-windows:
    name: Build Windows
    needs: create-release
    runs-on: windows-latest
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-pc-windows-msvc

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build app
        shell: bash
        run: |
          set -euo pipefail
          pnpm tauri build --config src-tauri/tauri.production.conf.json --target x86_64-pc-windows-msvc --no-bundle

      - name: Upload release assets (Windows)
        shell: bash
        run: |
          set -euo pipefail
          EXE_FILE="src-tauri/target/x86_64-pc-windows-msvc/release/filearchitect-app.exe"
          gh release upload "${GITHUB_REF_NAME}" "$EXE_FILE" --clobber
